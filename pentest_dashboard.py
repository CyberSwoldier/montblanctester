#!/usr/bin/env python3
"""Pentest Dashboard with Zero-Touch Dependency Management"""

import os
import sys
import inspect
import logging
import traceback
import subprocess
import importlib.util
from pathlib import Path
from typing import Dict, List, Optional, Any

import streamlit as st

# === Constants ===
EXPLOITS_DIR = Path("exploits")
UTILS_DIR = Path("utils")
REQUIREMENTS_FILE = Path("requirements.txt")
MODULE_TEMPLATE = '''"""Auto-generated pentest module"""

def example_scan(target: str) -> dict:
    """Example function that will appear in the UI"""
    return {"status": "success", "target": target}
'''

# === Logging Setup ===
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("pentest_dashboard.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# === Core Functions ===
def setup_environment() -> bool:
    """Ensure directory structure and critical packages exist"""
    try:
        # Create required directories
        EXPLOITS_DIR.mkdir(exist_ok=True)
        UTILS_DIR.mkdir(exist_ok=True)
        
        # Create __init__.py for proper Python packages
        (UTILS_DIR / "__init__.py").touch(exist_ok=True)
        
        # Create module templates if directory is empty
        if not any(EXPLOITS_DIR.iterdir()):
            for phase in get_pentest_phases():
                module_file = EXPLOITS_DIR / f"{phase}.py"
                if not module_file.exists():
                    module_file.write_text(MODULE_TEMPLATE)
            
            logger.info("Created default module templates")
        
        return True
    except Exception as e:
        logger.error(f"Environment setup failed: {e}")
        return False

def get_pentest_phases() -> List[str]:
    """Return standard pentest phases"""
    return [
        "reconnaissance",
        "vulnerability_scanning",
        "exploitation",
        "post_exploitation",
        "reporting"
    ]

def install_dependencies() -> bool:
    """Install requirements.txt if exists"""
    try:
        if REQUIREMENTS_FILE.exists():
            result = subprocess.run(
                [sys.executable, "-m", "pip", "install", "-r", str(REQUIREMENTS_FILE)],
                capture_output=True,
                text=True
            )
            
            if result.returncode != 0:
                logger.error(f"Dependency install failed:\n{result.stderr}")
                return False
            
            logger.info("Dependencies installed successfully")
        return True
    except Exception as e:
        logger.error(f"Dependency installation error: {e}")
        return False

def validate_packages() -> Dict[str, bool]:
    """Check for required pentest packages"""
    required = {
        'requests': 'Network operations',
        'lxml': 'XML processing',
        'python-nmap': 'Port scanning',
        'beautifulsoup4': 'HTML parsing',
        'colorama': 'Terminal coloring'
    }
    
    status = {}
    for pkg, desc in required.items():
        try:
            __import__(pkg)
            status[pkg] = True
        except ImportError:
            status[pkg] = False
            logger.warning(f"Missing package: {pkg} ({desc})")
    
    return status

def load_module(module_path: Path) -> Optional[Any]:
    """Safely load a single module with error recovery"""
    try:
        module_name = module_path.stem
        spec = importlib.util.spec_from_file_location(module_name, str(module_path))
        
        if spec is None or spec.loader is None:
            logger.error(f"Invalid module spec for {module_path}")
            return None
            
        module = importlib.util.module_from_spec(spec)
        sys.modules[module_name] = module
        spec.loader.exec_module(module)
        return module
    except Exception as e:
        logger.error(f"Failed to load {module_path}: {e}\n{traceback.format_exc()}")
        return None

def discover_modules() -> Dict[str, Any]:
    """Discover all valid pentest modules with error handling"""
    modules = {}
    
    for phase in get_pentest_phases():
        module_path = EXPLOITS_DIR / f"{phase}.py"
        
        if module_path.exists():
            module = load_module(module_path)
            if module is not None:
                modules[phase] = module
                logger.info(f"Loaded module: {phase}")
        else:
            logger.warning(f"Missing module: {phase}.py")
    
    return modules

def get_module_actions(module: Any) -> List[str]:
    """Extract all valid actions from a module"""
    actions = []
    
    for name, obj in inspect.getmembers(module):
        if inspect.isfunction(obj) and not name.startswith('_'):
            sig = inspect.signature(obj)
            if 'target' in sig.parameters:
                actions.append(name)
    
    return actions

# === UI Components ===
def show_dependency_status(status: Dict[str, bool]):
    """Display package status with installation options"""
    with st.expander("Dependency Status", expanded=False):
        cols = st.columns(3)
        
        for i, (pkg, installed) in enumerate(status.items()):
            col = cols[i % 3]
            if installed:
                col.success(f"‚úì {pkg}")
            else:
                col.error(f"‚úó {pkg}")
                if col.button(f"Install {pkg}"):
                    try:
                        subprocess.run([sys.executable, "-m", "pip", "install", pkg], check=True)
                        st.rerun()
                    except Exception as e:
                        st.error(f"Failed to install {pkg}: {e}")

def render_module_ui(modules: Dict[str, Any]):
    """Render the main pentest interface"""
    phase = st.sidebar.selectbox("Pentest Phase", list(modules.keys()))
    
    if phase in modules:
        actions = get_module_actions(modules[phase])
        
        if not actions:
            st.warning(f"No valid actions found in {phase}.py")
            st.code(MODULE_TEMPLATE, language='python')
            return
            
        action = st.sidebar.selectbox("Action", actions)
        target = st.sidebar.text_input("Target", "192.168.1.1")
        
        if st.sidebar.button("Execute", type="primary"):
            with st.spinner(f"Executing {phase}/{action}..."):
                try:
                    result = getattr(modules[phase], action)(target)
                    st.session_state.last_result = result
                    st.success("Execution completed!")
                    
                    with st.expander("Results", expanded=True):
                        st.json(result)
                        
                except Exception as e:
                    st.error(f"Execution failed: {e}")
                    with st.expander("Error Details"):
                        st.code(traceback.format_exc(), language='python')

# === Main Application ===
def main():
    st.set_page_config(
        page_title="Pentest Orchestrator",
        page_icon="üõ°Ô∏è",
        layout="wide"
    )
    
    st.title("üõ°Ô∏è Pentest Orchestrator")
    st.caption("Modular penetration testing dashboard")
    
    # Environment setup
    if not setup_environment():
        st.error("Failed to initialize environment. Check logs.")
        return
    
    # Dependency management
    if not install_dependencies():
        st.warning("Some dependencies failed to install")
    
    # Package validation
    pkg_status = validate_packages()
    show_dependency_status(pkg_status)
    
    # Module discovery
    modules = discover_modules()
    
    if not modules:
        st.error("No valid modules found. Default templates have been created.")
        st.code(MODULE_TEMPLATE, language='python')
        return
    
    # Main interface
    render_module_ui(modules)

if __name__ == "__main__":
    main()
